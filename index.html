<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zombie Game</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #333;
      }

      canvas {
        display: block;
      }

      .info {
        top: 10px;
        left: 10px;
        color: white;
        font-family: Arial, sans-serif;
        z-index: 10;
      }

      .permission-button,
      .pause-button,
      .shoot-button {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 5px;
        font-size: 16px;
        cursor: pointer;
      }

      .pause-button {
        top: 90%;
        left: 90%;
        transform: translate(-50%, -50%);
      }

      .shoot-button {
        top: 90%;
        left: 10%;
        transform: translate(-50%, -50%);
      }
    </style>
  </head>
  <body>
    <div class="info" id="infoText">Checking device capabilities...</div>
    <div class="info" id="pauseText">Pause with ESC or Button</div>
    <canvas id="gameCanvas"></canvas>
    <button
      id="permissionButton"
      class="permission-button"
      style="display: none"
    >
      Enable Accelerometer
    </button>
    <button id="pauseButton" class="pause-button" style="display: none">
      Pause
    </button>
    <button id="shootButton" class="shoot-button" style="display: none">
      Shoot
    </button>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const infoText = document.getElementById("infoText");
      const pauseText = document.getElementById("pauseText");
      const permissionButton = document.getElementById("permissionButton");
      const pauseButton = document.getElementById("pauseButton");
      const shootButton = document.getElementById("shootButton");

      const player = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 20,
        color: "blue",
        direction: { x: 0, y: 1 },
      };

      const zombies = [];
      const zombieSpeed = 2;

      const bullets = [];
      const bulletSpeed = 10;

      let tiltX = 0;
      let tiltY = 0;
      let controlMode = "none"; // 'accelerometer' or 'mouse'
      let accelerometerValid = false; // Check if accelerometer works
      let paused = false;

      function handleMouseMove(event) {
        const x = (event.clientX / window.innerWidth) * 180 - 90;
        const y = (event.clientY / window.innerHeight) * 180 - 90;

        tiltX = x;
        tiltY = y;

        if (controlMode === "mouse") {
          infoText.innerText = "Controlling with Mouse";
        }
      }

      function handleOrientation(event) {
        if (event.gamma === null || event.beta === null) {
          fallbackToMouse();
          return;
        }

        accelerometerValid = true;
        tiltX = event.gamma || 0;
        tiltY = event.beta || 0;

        if (controlMode === "accelerometer") {
          infoText.innerText = "Controlling with Accelerometer";
          pauseButton.style.display = "block";
          shootButton.style.display = "block";
        }
      }

      function requestAccelerometerPermission() {
        if (typeof DeviceOrientationEvent.requestPermission === "function") {
          DeviceOrientationEvent.requestPermission()
            .then((response) => {
              if (response === "granted") {
                controlMode = "accelerometer";
                window.addEventListener("deviceorientation", handleOrientation);
                permissionButton.style.display = "none";
              } else {
                fallbackToMouse();
              }
            })
            .catch(() => {
              fallbackToMouse();
            });
        } else {
          controlMode = "accelerometer";
          window.addEventListener("deviceorientation", handleOrientation);

          // Add a timeout to detect if accelerometer provides valid data
          setTimeout(() => {
            if (!accelerometerValid) {
              fallbackToMouse();
            }
          }, 1000); // Check after 1 second
        }
      }

      function fallbackToMouse() {
        controlMode = "mouse";
        window.addEventListener("mousemove", handleMouseMove);
        permissionButton.style.display = "none";
        infoText.innerText =
          "Controlling with Mouse (Accelerometer unavailable)";
        pauseText.innerText = "Pause with ESC";
        pauseButton.style.display = "none";
      }

      function initializeControls() {
        if (window.DeviceOrientationEvent) {
          if (typeof DeviceOrientationEvent.requestPermission === "function") {
            permissionButton.style.display = "block";
            permissionButton.addEventListener(
              "click",
              requestAccelerometerPermission
            );
            infoText.innerText =
              "Click the button to enable Accelerometer control.";
          } else {
            controlMode = "accelerometer";
            window.addEventListener("deviceorientation", handleOrientation);
            infoText.innerText = "Accelerometer control enabled.";

            // Add a timeout to detect valid accelerometer data
            setTimeout(() => {
              if (!accelerometerValid) {
                fallbackToMouse();
              }
            }, 1000);
          }
        } else {
          fallbackToMouse();
        }
      }

      function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);

        // Calculate rotation based on direction
        const angle = Math.atan2(player.direction.y, player.direction.x);
        ctx.rotate(angle);

        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fillStyle = player.color;
        ctx.fill();
        ctx.closePath();
        // Draw front (triangle)
        ctx.beginPath();
        ctx.moveTo(player.radius, 0);
        ctx.lineTo(player.radius / 2, -player.radius / 2);
        ctx.lineTo(player.radius / 2, player.radius / 2);
        ctx.closePath();
        ctx.fillStyle = "white";
        ctx.fill();

        ctx.restore();
      }

      function updatePlayer() {
        player.x += tiltX * 0.5;
        player.y += tiltY * 0.5;

        // Update direction
        if (tiltX !== 0 || tiltY !== 0) {
          const magnitude = Math.sqrt(tiltX * tiltX + tiltY * tiltY);
          player.direction.x = tiltX / magnitude;
          player.direction.y = tiltY / magnitude;
        }

        player.x = Math.max(
          player.radius,
          Math.min(canvas.width - player.radius, player.x)
        );
        player.y = Math.max(
          player.radius,
          Math.min(canvas.height - player.radius, player.y)
        );
      }

      function spawnZombie() {
        const side = Math.floor(Math.random() * 4);
        let x, y;

        if (side === 0) {
          x = Math.random() * canvas.width;
          y = -20;
        } else if (side === 1) {
          x = canvas.width + 20;
          y = Math.random() * canvas.height;
        } else if (side === 2) {
          x = Math.random() * canvas.width;
          y = canvas.height + 20;
        } else {
          x = -20;
          y = Math.random() * canvas.height;
        }

        zombies.push({
          x,
          y,
          radius: 10,
          color: "red",
          direction: { x: 0, y: 0 }, // Initialize direction
        });
      }

      function drawZombies() {
        zombies.forEach((zombie) => {
          ctx.save();
          ctx.translate(zombie.x, zombie.y);

          const angle = Math.atan2(zombie.direction.y, zombie.direction.x);
          ctx.rotate(angle);

          // Draw body (circle)
          ctx.beginPath();
          ctx.arc(0, 0, zombie.radius, 0, Math.PI * 2);
          ctx.fillStyle = zombie.color;
          ctx.fill();
          ctx.closePath();

          // Draw front (triangle)
          ctx.beginPath();
          ctx.moveTo(zombie.radius, 0);
          ctx.lineTo(zombie.radius / 2, -zombie.radius / 2);
          ctx.lineTo(zombie.radius / 2, zombie.radius / 2);
          ctx.closePath();
          ctx.fillStyle = "white";
          ctx.fill();

          ctx.restore();
        });
      }

      function updateZombies() {
        zombies.forEach((zombie) => {
          const dx = player.x - zombie.x;
          const dy = player.y - zombie.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          zombie.x += (dx / dist) * zombieSpeed;
          zombie.y += (dy / dist) * zombieSpeed;

          // Update zombie direction
          zombie.direction.x = dx / dist;
          zombie.direction.y = dy / dist;
        });
      }

      function shootBullets() {
        if (paused) return;

        // Generate 3 bullets with spread
        const spread = Math.PI / 12; // Spread angle for shotgun
        const baseAngle = Math.atan2(player.direction.y, player.direction.x);

        for (let i = -1; i <= 1; i++) {
          bullets.push({
            x: player.x,
            y: player.y,
            direction: {
              x: Math.cos(baseAngle + i * spread),
              y: Math.sin(baseAngle + i * spread),
            },
            radius: 5,
            color: "yellow",
          });
        }
      }

      function drawBullets() {
        bullets.forEach((bullet) => {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
          ctx.fillStyle = bullet.color;
          ctx.fill();
          ctx.closePath();
        });
      }

      function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.x += bullet.direction.x * bulletSpeed;
          bullet.y += bullet.direction.y * bulletSpeed;

          // Remove bullets that go out of bounds
          if (
            bullet.x < 0 ||
            bullet.x > canvas.width ||
            bullet.y < 0 ||
            bullet.y > canvas.height
          ) {
            bullets.splice(i, 1);
          }
        }
      }

      function checkCollisions() {
        if (paused) return;

        // Check bullet-zombie collisions
        for (let i = zombies.length - 1; i >= 0; i--) {
          const zombie = zombies[i];

          for (let j = bullets.length - 1; j >= 0; j--) {
            const bullet = bullets[j];
            const dx = zombie.x - bullet.x;
            const dy = zombie.y - bullet.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < zombie.radius + bullet.radius) {
              zombies.splice(i, 1);
              bullets.splice(j, 1);
              break;
            }
          }
        }

        // Check player-zombie collisions
        zombies.forEach((zombie, index) => {
          const dx = player.x - zombie.x;
          const dy = player.y - zombie.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < player.radius + zombie.radius) {
            alert("Game Over!");
            resetGame();
          }
        });
      }

      function resetGame() {
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        zombies.length = 0;
        bullets.length = 0;
      }

      function gameLoop() {
        if (!paused) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          drawPlayer();
          updatePlayer();
          drawZombies();
          updateZombies();
          drawBullets();
          updateBullets();
          checkCollisions();
        }

        requestAnimationFrame(gameLoop);
      }

      function togglePause() {
        paused = !paused;
        pauseButton.textContent = paused ? "Resume" : "Pause";
      }

      document.addEventListener("click", shootBullets);

      shootButton.addEventListener("click", shootBullets);

      pauseButton.addEventListener("click", togglePause);

      document.addEventListener("keydown", (event) => {
        if (controlMode === "mouse" && event.key === "Escape") {
          paused = !paused;
          pauseText.innerText = paused
            ? "Game Paused (Press ESC to Resume)"
            : "Pause with ESC";
        }
      });

      setInterval(spawnZombie, 1000);
      initializeControls();
      gameLoop();
    </script>
  </body>
</html>
